<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<title>Minecraft Clone - Fixed Controls</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { overflow: hidden; background: #000; font-family: 'Courier New', monospace; }
canvas { display: block; width: 100vw; height: 100vh; }
#crosshair {
  position: fixed; top: 50%; left: 50%;
  transform: translate(-50%, -50%);
  color: white; font-size: 30px; font-weight: bold;
  pointer-events: none; z-index: 10;
  text-shadow: 0 0 3px rgba(0,0,0,0.9);
  line-height: 1;
}
#hotbar {
  position: fixed; bottom: 10px; left: 50%;
  transform: translateX(-50%);
  display: flex; gap: 2px; z-index: 10;
}
.hotbar-slot {
  width: 52px; height: 52px;
  border: 3px solid #555;
  background: rgba(0,0,0,0.65);
  display: flex; align-items: center; justify-content: center;
  flex-direction: column;
  color: white; font-size: 9px; text-align: center;
  cursor: pointer;
  position: relative;
}
.hotbar-slot.active {
  border-color: #fff;
  background: rgba(255,255,255,0.25);
}
.hotbar-slot .block-preview {
  width: 32px; height: 32px;
  border: 1px solid rgba(0,0,0,0.3);
  margin-bottom: 2px;
}
.hotbar-slot .block-name {
  font-size: 7px;
  opacity: 0.8;
}
.hotbar-slot .slot-num {
  position: absolute;
  top: 1px; left: 3px;
  font-size: 8px;
  opacity: 0.5;
}
#info {
  position: fixed; top: 10px; left: 10px;
  color: white; font-size: 12px; z-index: 10;
  background: rgba(0,0,0,0.55); padding: 10px;
  border-radius: 4px; line-height: 1.8;
  min-width: 180px;
}
#startScreen {
  position: fixed; top: 0; left: 0; width: 100%; height: 100%;
  background: linear-gradient(180deg, rgba(0,0,0,0.9) 0%, rgba(20,40,20,0.95) 100%);
  display: flex; align-items: center; justify-content: center;
  flex-direction: column; z-index: 100; color: white;
}
#startScreen h1 {
  font-size: 52px; margin-bottom: 15px;
  color: #4a4;
  text-shadow: 3px 3px 0 #222, 5px 5px 0 rgba(0,0,0,0.3);
  letter-spacing: 6px;
}
#startScreen .controls {
  background: rgba(0,0,0,0.4);
  padding: 20px 30px;
  border-radius: 8px;
  margin: 10px 0;
}
#startScreen p { font-size: 14px; margin: 6px 0; color: #bbb; }
#startScreen p span { color: #8f8; font-weight: bold; }
#startScreen button {
  margin-top: 25px; padding: 15px 50px;
  font-size: 20px; cursor: pointer;
  background: #4a4; color: white; border: 3px solid #3a3;
  font-family: 'Courier New', monospace;
  letter-spacing: 3px;
  border-radius: 4px;
  transition: all 0.2s;
}
#startScreen button:hover { background: #5b5; transform: scale(1.05); }
</style>
</head>
<body>

<div id="startScreen">
  <h1>⛏ MINECRAFT</h1>
  <div class="controls">
    <p><span>Z/W</span> — Avancer</p>
    <p><span>S</span> — Reculer</p>
    <p><span>Q/A</span> — Gauche</p>
    <p><span>D</span> — Droite</p>
    <p><span>ESPACE</span> — Sauter</p>
    <p><span>SOURIS</span> — Regarder</p>
    <p><span>CLIC GAUCHE</span> — Casser un bloc</p>
    <p><span>CLIC DROIT</span> — Placer un bloc</p>
    <p><span>MOLETTE / 1-9</span> — Choisir bloc</p>
  </div>
  <button onclick="startGame()">▶ JOUER</button>
</div>

<div id="crosshair">✛</div>

<div id="info">
  <div id="fps">FPS: --</div>
  <div id="pos">Position: --</div>
  <div id="chunk">Chunk: --</div>
  <div id="triangles">Triangles: --</div>
  <div id="selected">Bloc: --</div>
</div>

<div id="hotbar"></div>

<canvas id="gameCanvas"></canvas>

<script>
// =====================================================
// PERLIN NOISE
// =====================================================
class PerlinNoise {
  constructor(seed) {
    this.perm = new Uint8Array(512);
    const p = new Uint8Array(256);
    for (let i = 0; i < 256; i++) p[i] = i;
    let s = seed || 42;
    for (let i = 255; i > 0; i--) {
      s = (s * 16807) % 2147483647;
      const j = s % (i + 1);
      [p[i], p[j]] = [p[j], p[i]];
    }
    for (let i = 0; i < 512; i++) this.perm[i] = p[i & 255];
  }
  fade(t) { return t * t * t * (t * (t * 6 - 15) + 10); }
  lerp(a, b, t) { return a + t * (b - a); }
  grad(hash, x, y) {
    const h = hash & 3;
    return ((h & 1) === 0 ? x : -x) + ((h & 2) === 0 ? y : -y);
  }
  noise2D(x, y) {
    const X = Math.floor(x) & 255, Y = Math.floor(y) & 255;
    x -= Math.floor(x); y -= Math.floor(y);
    const u = this.fade(x), v = this.fade(y);
    const A = this.perm[X] + Y, B = this.perm[X + 1] + Y;
    return this.lerp(
      this.lerp(this.grad(this.perm[A], x, y), this.grad(this.perm[B], x - 1, y), u),
      this.lerp(this.grad(this.perm[A + 1], x, y - 1), this.grad(this.perm[B + 1], x - 1, y - 1), u), v
    );
  }
  octave(x, y, oct, pers) {
    let t = 0, f = 1, a = 1, m = 0;
    for (let i = 0; i < oct; i++) {
      t += this.noise2D(x * f, y * f) * a;
      m += a; a *= pers; f *= 2;
    }
    return t / m;
  }
}

// =====================================================
// BLOCK TYPES
// =====================================================
const B = {
  AIR: 0, GRASS: 1, DIRT: 2, STONE: 3, WOOD: 4,
  LEAVES: 5, SAND: 6, WATER: 7, BEDROCK: 8, PLANKS: 9,
  COBBLE: 10, SNOW: 11, GLASS: 12
};

const BCOL = {
  [B.GRASS]:  { top:[76,153,38],  side:[100,82,38], bot:[100,82,38] },
  [B.DIRT]:   { top:[115,82,38],  side:[115,82,38], bot:[100,72,30] },
  [B.STONE]:  { top:[128,128,128],side:[115,115,115],bot:[100,100,100] },
  [B.WOOD]:   { top:[140,100,40], side:[100,65,25],  bot:[140,100,40] },
  [B.LEAVES]: { top:[38,128,25],  side:[30,115,20],  bot:[25,100,15] },
  [B.SAND]:   { top:[217,204,140],side:[204,191,128],bot:[191,178,115] },
  [B.WATER]:  { top:[38,76,204],  side:[25,64,191],  bot:[25,51,178] },
  [B.BEDROCK]:{ top:[51,51,51],   side:[38,38,38],   bot:[25,25,25] },
  [B.PLANKS]: { top:[166,128,64], side:[153,115,51], bot:[140,102,46] },
  [B.COBBLE]: { top:[102,102,107],side:[97,97,102],  bot:[89,89,95] },
  [B.SNOW]:   { top:[242,242,250],side:[230,230,237],bot:[217,217,224] },
  [B.GLASS]:  { top:[178,217,230],side:[178,217,230],bot:[178,217,230] },
};

const BNAME = {
  [B.GRASS]:'Herbe',[B.DIRT]:'Terre',[B.STONE]:'Pierre',[B.WOOD]:'Bois',
  [B.LEAVES]:'Feuilles',[B.SAND]:'Sable',[B.PLANKS]:'Planches',
  [B.COBBLE]:'Pavé',[B.GLASS]:'Verre',[B.SNOW]:'Neige',
};

const TRANSPARENT = new Set([B.AIR, B.WATER, B.GLASS, B.LEAVES]);

// =====================================================
// WORLD
// =====================================================
const CS = 16;
const WH = 64;
const RDIST = 4;
const SEA = 18;

class World {
  constructor(seed) {
    this.chunks = new Map();
    this.perlin = new PerlinNoise(seed);
    this.mods = new Map();
  }
  ckey(cx, cz) { return cx + ',' + cz; }
  bkey(x, y, z) { return x + ',' + y + ',' + z; }

  heightAt(wx, wz) {
    let h = this.perlin.octave(wx * 0.007, wz * 0.007, 5, 0.5);
    h = (h + 1) * 0.5;
    h = Math.pow(h, 1.4);
    return Math.floor(h * 28) + 8;
  }

  genChunk(cx, cz) {
    const k = this.ckey(cx, cz);
    if (this.chunks.has(k)) return;
    const blocks = new Uint8Array(CS * WH * CS);

    for (let x = 0; x < CS; x++) {
      for (let z = 0; z < CS; z++) {
        const wx = cx * CS + x;
        const wz = cz * CS + z;
        const h = this.heightAt(wx, wz);
        for (let y = 0; y < WH; y++) {
          let b = B.AIR;
          if (y === 0) b = B.BEDROCK;
          else if (y < h - 4) b = B.STONE;
          else if (y < h) b = B.DIRT;
          else if (y === h) {
            if (h < SEA - 1) b = B.SAND;
            else if (h > 40) b = B.SNOW;
            else b = B.GRASS;
          } else if (y <= SEA && y > h) {
            b = B.WATER;
          }
          blocks[(x * WH + y) * CS + z] = b;
        }
        if (h > SEA && h < 38) {
          const tv = Math.abs(this.perlin.noise2D(wx * 0.8, wz * 0.8));
          if (tv > 0.38 && ((wx & 7) < 2) && ((wz & 7) < 2)) {
            const th = 4 + (Math.abs(this.perlin.noise2D(wx*3.1, wz*3.1)) * 3 | 0);
            for (let ty = 1; ty <= th; ty++) {
              const yy = h + ty;
              if (yy < WH) blocks[(x * WH + yy) * CS + z] = B.WOOD;
            }
            for (let lx = -2; lx <= 2; lx++)
              for (let lz = -2; lz <= 2; lz++)
                for (let ly = th - 1; ly <= th + 2; ly++) {
                  if (Math.abs(lx) === 2 && Math.abs(lz) === 2 && ly > th) continue;
                  const bx = x + lx, bz = z + lz, by = h + ly;
                  if (bx >= 0 && bx < CS && bz >= 0 && bz < CS && by > 0 && by < WH) {
                    if (blocks[(bx * WH + by) * CS + bz] === B.AIR)
                      blocks[(bx * WH + by) * CS + bz] = B.LEAVES;
                  }
                }
          }
        }
      }
    }
    for (let x = 0; x < CS; x++)
      for (let y = 0; y < WH; y++)
        for (let z = 0; z < CS; z++) {
          const bk = this.bkey(cx*CS+x, y, cz*CS+z);
          if (this.mods.has(bk))
            blocks[(x * WH + y) * CS + z] = this.mods.get(bk);
        }
    this.chunks.set(k, { blocks, cx, cz, mesh: null, dirty: true });
  }

  getBlock(x, y, z) {
    if (y < 0 || y >= WH) return B.AIR;
    const bk = this.bkey(x, y, z);
    if (this.mods.has(bk)) return this.mods.get(bk);
    const cx = Math.floor(x / CS), cz = Math.floor(z / CS);
    const ch = this.chunks.get(this.ckey(cx, cz));
    if (!ch) return B.AIR;
    const lx = ((x % CS) + CS) % CS;
    const lz = ((z % CS) + CS) % CS;
    return ch.blocks[(lx * WH + y) * CS + lz];
  }

  setBlock(x, y, z, type) {
    if (y < 0 || y >= WH) return;
    this.mods.set(this.bkey(x, y, z), type);
    const cx = Math.floor(x / CS), cz = Math.floor(z / CS);
    const ch = this.chunks.get(this.ckey(cx, cz));
    if (ch) {
      const lx = ((x % CS) + CS) % CS;
      const lz = ((z % CS) + CS) % CS;
      ch.blocks[(lx * WH + y) * CS + lz] = type;
      ch.dirty = true;
    }
    const lx = ((x % CS) + CS) % CS;
    const lz = ((z % CS) + CS) % CS;
    if (lx === 0) this._dirty(cx-1, cz);
    if (lx === CS-1) this._dirty(cx+1, cz);
    if (lz === 0) this._dirty(cx, cz-1);
    if (lz === CS-1) this._dirty(cx, cz+1);
  }

  _dirty(cx, cz) {
    const ch = this.chunks.get(this.ckey(cx, cz));
    if (ch) ch.dirty = true;
  }

  loadAround(px, pz) {
    const cx = Math.floor(px / CS), cz = Math.floor(pz / CS);
    for (let dx = -RDIST; dx <= RDIST; dx++)
      for (let dz = -RDIST; dz <= RDIST; dz++)
        if (dx*dx + dz*dz <= RDIST*RDIST + 2)
          this.genChunk(cx+dx, cz+dz);
  }
}

// =====================================================
// WEBGL
// =====================================================
const canvas = document.getElementById('gameCanvas');
const gl = canvas.getContext('webgl', { antialias: false, alpha: false });

function resize() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
  if (gl) gl.viewport(0, 0, canvas.width, canvas.height);
}
window.addEventListener('resize', resize);
resize();

const VS = `
attribute vec3 aP;
attribute vec3 aC;
attribute float aL;
attribute vec3 aN;
uniform mat4 uMVP;
varying vec3 vC;
varying float vL;
varying float vF;
varying vec3 vN;
void main(){
  gl_Position = uMVP * vec4(aP,1.0);
  vC = aC;
  vL = aL;
  vN = aN;
  vF = clamp(gl_Position.z / 90.0, 0.0, 1.0);
}`;
const FS = `
precision mediump float;
varying vec3 vC;
varying float vL;
varying float vF;
varying vec3 vN;
uniform vec3 uSky;
uniform vec3 uSun;
uniform float uAmb;
void main(){
  float sun = max(dot(vN, uSun), 0.0) * 0.35;
  float l = vL * (uAmb + sun);
  vec3 c = vC * l;
  c = mix(c, uSky, vF * vF);
  gl_FragColor = vec4(c, 1.0);
}`;

function mkShader(src, type) {
  const s = gl.createShader(type);
  gl.shaderSource(s, src);
  gl.compileShader(s);
  return s;
}

const prog = gl.createProgram();
gl.attachShader(prog, mkShader(VS, gl.VERTEX_SHADER));
gl.attachShader(prog, mkShader(FS, gl.FRAGMENT_SHADER));
gl.linkProgram(prog);
gl.useProgram(prog);

const aP = gl.getAttribLocation(prog, 'aP');
const aC = gl.getAttribLocation(prog, 'aC');
const aL = gl.getAttribLocation(prog, 'aL');
const aN = gl.getAttribLocation(prog, 'aN');
const uMVP = gl.getUniformLocation(prog, 'uMVP');
const uSky = gl.getUniformLocation(prog, 'uSky');
const uSun = gl.getUniformLocation(prog, 'uSun');
const uAmb = gl.getUniformLocation(prog, 'uAmb');

gl.enable(gl.DEPTH_TEST);
gl.enable(gl.CULL_FACE);
gl.cullFace(gl.BACK);

// =====================================================
// MATRIX
// =====================================================
const m4 = {
  create() { return new Float32Array([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]); },
  perspective(fov, asp, near, far) {
    const f = 1 / Math.tan(fov/2), nf = 1/(near-far);
    return new Float32Array([f/asp,0,0,0, 0,f,0,0, 0,0,(far+near)*nf,-1, 0,0,2*far*near*nf,0]);
  },
  mul(a, b) {
    const r = new Float32Array(16);
    for (let i=0;i<4;i++) for(let j=0;j<4;j++){
      let s=0; for(let k=0;k<4;k++) s+=a[k*4+i]*b[j*4+k]; r[j*4+i]=s;
    } return r;
  },
  rotX(m, a) {
    const r = m4.create(), s=Math.sin(a), c=Math.cos(a);
    r[5]=c;r[6]=s;r[9]=-s;r[10]=c; return m4.mul(m,r);
  },
  rotY(m, a) {
    const r = m4.create(), s=Math.sin(a), c=Math.cos(a);
    r[0]=c;r[2]=-s;r[8]=s;r[10]=c; return m4.mul(m,r);
  },
  trans(m, x, y, z) {
    const r = m4.create(); r[12]=x;r[13]=y;r[14]=z; return m4.mul(m,r);
  }
};

// =====================================================
// MESH BUILDER
// =====================================================
function buildMesh(world, chunk) {
  const verts = [];
  const { cx, cz, blocks } = chunk;

  for (let x = 0; x < CS; x++) {
    for (let y = 0; y < WH; y++) {
      for (let z = 0; z < CS; z++) {
        const block = blocks[(x * WH + y) * CS + z];
        if (block === B.AIR || block === B.WATER) continue;

        const wx = cx * CS + x;
        const wz = cz * CS + z;
        const col = BCOL[block];
        if (!col) continue;

        const faces = [
          { dx:0,dy:1,dz:0,  n:[0,1,0],   c:[[0,1,1],[1,1,1],[1,1,0],[0,1,0]], rgb:col.top, l:1.0 },
          { dx:0,dy:-1,dz:0, n:[0,-1,0],  c:[[0,0,0],[1,0,0],[1,0,1],[0,0,1]], rgb:col.bot, l:0.5 },
          { dx:0,dy:0,dz:1,  n:[0,0,1],   c:[[0,0,1],[1,0,1],[1,1,1],[0,1,1]], rgb:col.side,l:0.8 },
          { dx:0,dy:0,dz:-1, n:[0,0,-1],  c:[[1,0,0],[0,0,0],[0,1,0],[1,1,0]], rgb:col.side,l:0.7 },
          { dx:1,dy:0,dz:0,  n:[1,0,0],   c:[[1,0,1],[1,0,0],[1,1,0],[1,1,1]], rgb:col.side,l:0.9 },
          { dx:-1,dy:0,dz:0, n:[-1,0,0],  c:[[0,0,0],[0,0,1],[0,1,1],[0,1,0]], rgb:col.side,l:0.6 },
        ];

        for (const f of faces) {
          const nb = world.getBlock(wx+f.dx, y+f.dy, wz+f.dz);
          if (!TRANSPARENT.has(nb)) continue;
          if (nb === block && block === B.GLASS) continue;

          const q = f.c;
          const r = f.rgb[0]/255, g = f.rgb[1]/255, b = f.rgb[2]/255;
          for (const idx of [0,1,2, 0,2,3]) {
            verts.push(
              wx + q[idx][0], y + q[idx][1], wz + q[idx][2],
              r, g, b, f.l,
              f.n[0], f.n[1], f.n[2]
            );
          }
        }
      }
    }
  }

  if (chunk.mesh && chunk.mesh.buf) gl.deleteBuffer(chunk.mesh.buf);

  if (verts.length === 0) {
    chunk.mesh = { buf: null, cnt: 0 };
    chunk.dirty = false;
    return;
  }

  const data = new Float32Array(verts);
  const buf = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, buf);
  gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW);
  chunk.mesh = { buf, cnt: verts.length / 10 };
  chunk.dirty = false;
}

// =====================================================
// PLAYER
// =====================================================
const player = {
  x: 0, y: 40, z: 0,
  vy: 0,
  yaw: 0, pitch: 0,
  onGround: false,
  W: 0.28, H: 1.62, EYE: 1.5,
  slot: 0,
  inv: [B.GRASS, B.DIRT, B.STONE, B.WOOD, B.PLANKS, B.COBBLE, B.SAND, B.GLASS, B.LEAVES]
};

// =====================================================
// INPUT
// =====================================================
const keys = {};
window.addEventListener('keydown', e => {
  keys[e.code] = true;
  if (e.key >= '1' && e.key <= '9') {
    player.slot = parseInt(e.key) - 1;
    refreshHotbar();
  }
  if (['Space','KeyW','KeyA','KeyS','KeyD','KeyZ','KeyQ'].includes(e.code))
    e.preventDefault();
});
window.addEventListener('keyup', e => { keys[e.code] = false; });

// ========== CAMERA : mouvement souris corrigé (INVERSION ICI) ==========
document.addEventListener('mousemove', e => {
  if (!gameOn || !document.pointerLockElement) return;
  // J'ai changé += en -= pour que la rotation suive la souris
  player.yaw -= e.movementX * 0.002;
  player.pitch -= e.movementY * 0.002;
  player.pitch = Math.max(-1.55, Math.min(1.55, player.pitch));
});

window.addEventListener('wheel', e => {
  if (!gameOn) return;
  player.slot = ((player.slot + Math.sign(e.deltaY)) % 9 + 9) % 9;
  refreshHotbar();
}, { passive: true });

// ========== Fonction pour obtenir la direction de la caméra ==========
function getCamDir() {
  const cp = Math.cos(player.pitch);
  return {
    x: Math.sin(player.yaw) * cp,
    y: Math.sin(player.pitch),
    z: Math.cos(player.yaw) * cp
  };
}

canvas.addEventListener('mousedown', e => {
  if (!gameOn) return;
  if (!document.pointerLockElement) {
    canvas.requestPointerLock();
    return;
  }
  e.preventDefault();

  const dir = getCamDir();
  const hit = raycast(world, player.x, player.y + player.EYE, player.z, dir.x, dir.y, dir.z, 7);
  if (!hit) return;

  if (e.button === 0) {
    if (hit.block !== B.BEDROCK)
      world.setBlock(hit.x, hit.y, hit.z, B.AIR);
  } else if (e.button === 2) {
    const px = hit.px, py = hit.py, pz = hit.pz;
    const w = player.W;
    if (px + 1 <= player.x - w || px >= player.x + w ||
        py + 1 <= player.y || py >= player.y + player.H ||
        pz + 1 <= player.z - w || pz >= player.z + w) {
      world.setBlock(px, py, pz, player.inv[player.slot]);
    }
  }
});
canvas.addEventListener('contextmenu', e => e.preventDefault());

// =====================================================
// RAYCAST
// =====================================================
function raycast(world, ox, oy, oz, dx, dy, dz, maxDist) {
  let x = Math.floor(ox), y = Math.floor(oy), z = Math.floor(oz);
  const sx = dx >= 0 ? 1 : -1;
  const sy = dy >= 0 ? 1 : -1;
  const sz = dz >= 0 ? 1 : -1;

  let tMaxX = dx !== 0 ? ((dx > 0 ? (x+1) - ox : ox - x)) / Math.abs(dx) : 1e10;
  let tMaxY = dy !== 0 ? ((dy > 0 ? (y+1) - oy : oy - y)) / Math.abs(dy) : 1e10;
  let tMaxZ = dz !== 0 ? ((dz > 0 ? (z+1) - oz : oz - z)) / Math.abs(dz) : 1e10;

  const tDX = dx !== 0 ? Math.abs(1/dx) : 1e10;
  const tDY = dy !== 0 ? Math.abs(1/dy) : 1e10;
  const tDZ = dz !== 0 ? Math.abs(1/dz) : 1e10;

  let px = x, py = y, pz = z;

  for (let i = 0; i < 200; i++) {
    const block = world.getBlock(x, y, z);
    if (block !== B.AIR && block !== B.WATER) {
      return { x, y, z, block, px, py, pz };
    }
    px = x; py = y; pz = z;

    if (tMaxX < tMaxY) {
      if (tMaxX < tMaxZ) {
        if (tMaxX > maxDist) break;
        x += sx; tMaxX += tDX;
      } else {
        if (tMaxZ > maxDist) break;
        z += sz; tMaxZ += tDZ;
      }
    } else {
      if (tMaxY < tMaxZ) {
        if (tMaxY > maxDist) break;
        y += sy; tMaxY += tDY;
      } else {
        if (tMaxZ > maxDist) break;
        z += sz; tMaxZ += tDZ;
      }
    }
  }
  return null;
}

// =====================================================
// COLLISION
// =====================================================
function collidesAt(world, px, py, pz) {
  const w = player.W;
  const h = player.H;
  const x0 = Math.floor(px - w), x1 = Math.floor(px + w);
  const y0 = Math.floor(py), y1 = Math.floor(py + h);
  const z0 = Math.floor(pz - w), z1 = Math.floor(pz + w);

  for (let bx = x0; bx <= x1; bx++)
    for (let by = y0; by <= y1; by++)
      for (let bz = z0; bz <= z1; bz++) {
        const b = world.getBlock(bx, by, bz);
        if (b === B.AIR || b === B.WATER) continue;
        if (px + w > bx && px - w < bx + 1 &&
            py + h > by && py < by + 1 &&
            pz + w > bz && pz - w < bz + 1)
          return true;
      }
  return false;
}

// =====================================================
// HOTBAR
// =====================================================
const hotbarEl = document.getElementById('hotbar');

function refreshHotbar() {
  hotbarEl.innerHTML = '';
  player.inv.forEach((block, i) => {
    const slot = document.createElement('div');
    slot.className = 'hotbar-slot' + (i === player.slot ? ' active' : '');
    const col = BCOL[block]?.top || [255,255,255];
    slot.innerHTML = `
      <span class="slot-num">${i+1}</span>
      <div class="block-preview" style="background:rgb(${col[0]},${col[1]},${col[2]})"></div>
      <span class="block-name">${BNAME[block]||''}</span>`;
    slot.addEventListener('mousedown', e => {
      e.stopPropagation();
      player.slot = i;
      refreshHotbar();
    });
    hotbarEl.appendChild(slot);
  });
  document.getElementById('selected').textContent = 'Bloc: ' + (BNAME[player.inv[player.slot]] || '?');
}

// =====================================================
// GAME LOOP
// =====================================================
let world;
let gameOn = false;
let dayTime = 0.25;
let lastT = 0;
let fpsCnt = 0, fpsT = 0, fpsVal = 0;

function update(dt) {
  dt = Math.min(dt, 0.05);

  // ========== TOUCHES CORRIGÉES (Z/S INVERSÉS ICI) ==========
  
  let mx = 0, mz = 0;

  const fwdX = Math.sin(player.yaw);
  const fwdZ = Math.cos(player.yaw);
  const rightX = Math.cos(player.yaw);
  const rightZ = -Math.sin(player.yaw);

  // Z/W doit AVANCER => on SOUSTRAIT le vecteur avant (car la cam regarde vers -Z)
  if (keys['KeyW'] || keys['KeyZ']) { mx -= fwdX; mz -= fwdZ; }
  
  // S doit RECULER => on AJOUTE le vecteur avant
  if (keys['KeyS'])                 { mx += fwdX; mz += fwdZ; }
  
  // Q/D pour strafer (ça reste pareil ou inversé selon le repère, mais là c'est synchro)
  if (keys['KeyA'] || keys['KeyQ']) { mx -= rightX; mz -= rightZ; }
  if (keys['KeyD'])                 { mx += rightX; mz += rightZ; }

  const len = Math.sqrt(mx*mx + mz*mz);
  if (len > 0) { mx /= len; mz /= len; }

  const speed = 5.0 * dt;

  const nx = player.x + mx * speed;
  if (!collidesAt(world, nx, player.y, player.z)) player.x = nx;

  const nz = player.z + mz * speed;
  if (!collidesAt(world, player.x, player.y, nz)) player.z = nz;

  // Jump
  if (keys['Space'] && player.onGround) {
    player.vy = 7.8;
    player.onGround = false;
  }

  // Gravity
  player.vy -= 24 * dt;
  if (player.vy < -40) player.vy = -40;
  const ny = player.y + player.vy * dt;
  if (!collidesAt(world, player.x, ny, player.z)) {
    player.y = ny;
    player.onGround = false;
  } else {
    if (player.vy < 0) player.onGround = true;
    player.vy = 0;
  }

  if (player.y < -20) { player.y = 50; player.vy = 0; }

  dayTime += dt * 0.015;
  world.loadAround(player.x, player.z);
}

function render() {
  const sunA = dayTime * Math.PI * 2;
  const sunH = Math.sin(sunA);
  const df = Math.max(0, Math.min(1, sunH * 2 + 0.5));

  const sr = 0.05 + 0.50 * df;
  const sg = 0.08 + 0.55 * df;
  const sb = 0.18 + 0.65 * df;

  gl.clearColor(sr, sg, sb, 1);
  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

  const asp = canvas.width / canvas.height;
  const proj = m4.perspective(75 * Math.PI / 180, asp, 0.1, 200);

  let view = m4.create();
  view = m4.rotX(view, -player.pitch);      
  view = m4.rotY(view, -player.yaw);        
  view = m4.trans(view, -player.x, -(player.y + player.EYE), -player.z);

  const mvp = m4.mul(proj, view);

  gl.uniformMatrix4fv(uMVP, false, mvp);
  gl.uniform3f(uSky, sr, sg, sb);

  const sdx = Math.cos(sunA)*0.5, sdy = Math.sin(sunA), sdz = Math.sin(sunA)*0.3;
  const sl = Math.sqrt(sdx*sdx+sdy*sdy+sdz*sdz);
  gl.uniform3f(uSun, sdx/sl, sdy/sl, sdz/sl);
  gl.uniform1f(uAmb, 0.3 + 0.5 * df);

  const stride = 40;
  let totalV = 0;
  let meshesBuilt = 0;

  for (const [, ch] of world.chunks) {
    if ((ch.dirty || !ch.mesh) && meshesBuilt < 3) {
      buildMesh(world, ch);
      meshesBuilt++;
    }
    if (!ch.mesh || !ch.mesh.buf || ch.mesh.cnt === 0) continue;

    const cdx = (ch.cx * CS + CS/2) - player.x;
    const cdz = (ch.cz * CS + CS/2) - player.z;
    const maxD = (RDIST + 1) * CS;
    if (cdx*cdx + cdz*cdz > maxD*maxD) continue;

    gl.bindBuffer(gl.ARRAY_BUFFER, ch.mesh.buf);
    gl.enableVertexAttribArray(aP);
    gl.vertexAttribPointer(aP, 3, gl.FLOAT, false, stride, 0);
    gl.enableVertexAttribArray(aC);
    gl.vertexAttribPointer(aC, 3, gl.FLOAT, false, stride, 12);
    gl.enableVertexAttribArray(aL);
    gl.vertexAttribPointer(aL, 1, gl.FLOAT, false, stride, 24);
    gl.enableVertexAttribArray(aN);
    gl.vertexAttribPointer(aN, 3, gl.FLOAT, false, stride, 28);

    gl.drawArrays(gl.TRIANGLES, 0, ch.mesh.cnt);
    totalV += ch.mesh.cnt;
  }

  document.getElementById('triangles').textContent = 'Triangles: ' + ((totalV/3)|0);
  document.getElementById('pos').textContent = `Pos: ${player.x.toFixed(1)}, ${player.y.toFixed(1)}, ${player.z.toFixed(1)}`;
  document.getElementById('chunk').textContent = `Chunk: ${Math.floor(player.x/CS)}, ${Math.floor(player.z/CS)}`;
}

function loop(t) {
  requestAnimationFrame(loop);
  if (!gameOn) return;
  const dt = Math.min((t - lastT) / 1000, 0.1);
  lastT = t;

  fpsCnt++;
  fpsT += dt;
  if (fpsT >= 1) { fpsVal = fpsCnt; fpsCnt = 0; fpsT -= 1; }
  document.getElementById('fps').textContent = 'FPS: ' + fpsVal;

  update(dt);
  render();
}

function startGame() {
  document.getElementById('startScreen').style.display = 'none';
  gameOn = true;

  const seed = Math.random() * 999999 | 0;
  world = new World(seed);

  const sh = world.heightAt(0, 0);
  player.x = 0.5;
  player.y = sh + 3;
  player.z = 0.5;

  world.loadAround(player.x, player.z);
  refreshHotbar();

  canvas.requestPointerLock();
  lastT = performance.now();
  requestAnimationFrame(loop);
}

canvas.addEventListener('click', () => {
  if (gameOn && !document.pointerLockElement) canvas.requestPointerLock();
});
</script>
</body>
</html>
